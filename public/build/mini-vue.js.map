{"version":3,"file":"mini-vue.js","sources":["../../src/util/index.ts","../../src/reactivity/effect.ts","../../src/reactivity/reactive.ts","../../src/index.ts"],"sourcesContent":["export function isObject(target) {\n    return typeof target === 'object' && target !== null;\n}\n\nexport function isReactive(target) {\n    return !!(target && target.__isReactive);\n}\n\nexport function hasChanged(oldValue, value) {\n    return oldValue !== value && !(Number.isNaN(oldValue) && Number.isNaN(value));\n}\n\nexport function isFunction(target) {\n    return typeof target === 'function';\n}","// 该参数用来记录此时执行的 effect内传入的方法，用来记录存储\nlet activeEffect;\n// 使用栈的方式存储effect触发的嵌套情形，避免出现嵌套effect最终导致 activeEffect指向方法错误，最终变量监听修改的变量会有问题\nconst effctStack = [];\nexport function effect(fn, options: any = {}) {\n    const effectFn = () => {\n        /**\n         * 这里记录进行进栈出栈操作，并且记录此时记录的activeEffect\n         * 在fn执行时查找会调用方法，并触发相应依赖变量的get方法\n         * 这里的方法执行有点诡异，在try finally中，如果有return会在finally执行后再return。 \n         * try中return并不会截断finally的执行，但是如果return是方法，它会在finally中代码之前执行\n         * ps: 呐呐呐，面试题这不就来了。但是一般谁tm会注意这个啊\n        */\n        try {\n            activeEffect = effectFn;\n            effctStack.push(effectFn);\n            return fn()\n        } finally {\n            effctStack.pop();\n            activeEffect = effctStack[effctStack.length - 1];\n        }\n    }\n    // lazy 用来控制是否进行首次执行回调fn\n    // 例如effect方法注册时会自动执行一次，可是computed并不会一声明就执行，只有该computed所声明的变量被引用时才会执行，并做依赖收集\n    if(!options.lazy) {\n        effectFn();\n    }\n    // scheduler 控制权交出，computed等方法会自定义一些逻辑在里面\n    effectFn.scheduler = options.scheduler;\n    return effectFn;\n}\n\n\n\n// targetMap 用来存储所有监听的对象哈希映射，WeakMap 弱引用，防止内存泄漏。\nlet targetMap = new WeakMap();\n// 依赖收集\nexport function track(target, key) {\n    if(!activeEffect) return;\n    // depsMap 用来存储监听对象(完整数据对象，例如reactive括号内声明的完整变量)\n    let depsMap = targetMap.get(target);\n    // 如果没有监听过该对象，就将它添加到targetMap中 并将其值为一个新的map\n    if(!depsMap) targetMap.set(target, (depsMap = new Map()));\n    // deps 用来存储此时depsMap 这个map中是否有过某个值的引用 例如引用了reactive括号内声明的某个变量\n    let deps = depsMap.get(key);\n    // 如果没有该对象属性的监听，那么就声明一个set\n    if(!deps) depsMap.set(key, (deps = new Set()));\n    // 利用set的不重复特性，存储当前的执行方法，例如每个computed内部的方法，都是一个新的执行方法。\n    // 将这些方法收集到set中存下来，当触发某个变量的set方法时 再遍历这里存储的deps就可以更新所有的变量变化了\n    deps.add(activeEffect);\n}\n\n// 触发更新\nexport function trigger(target, key) {\n    // 和track一一对应的逻辑，取出相应变量之前存储的所有方法，并且遍历执行，这样就可以更新所有computed中修改的值了\n    const depsMap = targetMap.get(target);\n    if(!depsMap) return;\n    const deps = depsMap.get(key);\n    if(!deps) return;\n    deps.forEach(effectFn => {\n        if(effectFn.scheduler) {\n            effectFn.scheduler()\n        } else {\n            effectFn();\n        }\n    });\n}\n","import { isObject, isReactive, hasChanged } from \"../util\";\nimport { trigger, track } from \"./effect\";\nconst proxyMap = new WeakMap();\nexport function reactive(target) {\n    if(!isObject(target)) {\n        return  target;\n    }\n    if(isReactive(target)) {\n        return  target;\n    }\n    if(proxyMap.has(target)) {\n        return target;\n    }\n    const proxy = new Proxy(target, {\n        get(target, key, receiver) {\n            // 这里增加个 __isReactive 表示位用来判断是否为reactive\n            if (key === '__isReactive') return true;\n            const res = Reflect.get(target, key, receiver);\n            // 依赖收集，存下来此时要更新的变量\n            track(target, key);\n            if(isObject(res)) {\n                Reflect.set(target, key, reactive(res), receiver);\n                return Reflect.get(target, key, receiver);\n            } else {\n                return res;\n            }\n        },\n        set(target, key, value, receiver) {\n            const oldLength = target.length;\n            const oldValue = Reflect.get(target, key, receiver);\n            const res = Reflect.set(target, key, value, receiver);\n            // 只有真正触发了变量更新才进行修改\n            if(hasChanged(oldValue, value)) {\n                trigger(target, key);\n                if(Array.isArray(target) && hasChanged(oldLength, target.length)) {\n                    trigger(target, 'length');\n                }\n            } \n            return res;\n        }\n    });\n    \n    proxyMap.set(target, proxy);\n    return proxy;\n}","// @ts-nocheck\nimport { reactive } from \"./reactivity/reactive\";\nimport { effect } from \"./reactivity/effect\";\nimport { ref } from \"./reactivity/ref\";\nimport { computed } from \"./reactivity/computed\";\n\n// 常规模式 + 对象嵌套\nconst testdemo = (window.testdemo = reactive({\n    count: 1,\n    depObj: {\n        count: 2\n    }\n}));\neffect(() => {\n    console.log('testdemo.count', testdemo.count);\n});\neffect(() => {\n    console.log('testdemo.depObj.count', testdemo.depObj.count);\n});\n\n// 数组\n// const testdemo = (window.testdemo = reactive([1,2,3]));\n// effect(() => {\n//     console.log('testdemo[4] ', testdemo[4]);\n// });\n// effect(() => {\n//     console.log('testdemo.length ', testdemo.length);\n// });\n\n// 嵌套effect\n// const testdemo = (window.testdemo = reactive({\n//     count1: 1,\n//     count2: 2\n// }));\n// effect(() => {\n//     effect(() => {\n//         console.log('testdemo.count2 ', testdemo.count2);\n//     });\n//     console.log('testdemo.count1 ', testdemo.count1);\n// });\n\n// ref 测试\n// const testdemo = (window.testdemo = ref(2));\n// effect(() => {\n//     console.log('testdemo.value ', testdemo.value);\n// });\n\n// computed 测试\n// const testdemo = (window.testdemo = ref(2));\n// const c = (window.c = computed(() => {\n//     console.log('testdemo.value ', testdemo.value);\n//     return testdemo.value * 3;\n// }));\n\n"],"names":[],"mappings":"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"}